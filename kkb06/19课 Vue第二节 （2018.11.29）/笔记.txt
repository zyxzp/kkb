1. 我在做上次的Koa2项目时，发现向数据库写入图片地址时，地址超过32位，数据库没有报错，而是默默把字符串截成32位，按理说不是应该要报错的吗？  存date的时候，我传的是2018-11-11，结果写入了2018，没报错。

2. koa-better-body似乎前端如果未上传文件，也会生成一个大小为0的文件？而且只要经过了koa-better-body，即使我数据库因报错未写入数据，文件也会上传成功。  是否有比较好的办法能够保证一切正常之后才生成文件？

3. 列表分页的SQL语句怎么写？
LIMIT start,count;

api/get/...?page=1

let page_size=10;
let page=2;

let SQL=`SELECT * FROM xxx_table WHERE xxx LIMIT ?,?`, [(page-1)*page_size, page_size]

4. 数据表连接时，不以主表的值连接怎么做？

那意思是文件肯定会传到服务器，只是需要之后再手动删除？

--------------------------------------------------------------------------------

我是希望我如果判断除了文件之外的数据是错误的，文件不要上传到服务器

--------------------------------------------------------------------------------

事件修饰符

stop        禁止冒泡
once        单次事件
prevent     阻止默认事件
native      原生事件（组件）
keycode|name   筛选按键

self
capture

--------------------------------------------------------------------------------

@click="fn()"
@click.stop="fn()"

--------------------------------------------------------------------------------

computed——计算属性
1.缓存——性能
2.方便
  读、写
  属性的形式

--------------------------------------------------------------------------------

watch——监听：

--------------------------------------------------------------------------------

vue-router
数据交互
组件

--------------------------------------------------------------------------------

vue-router
1.容器
  <router-view></router-view>

2.路由表
  let router=new VueRouter({
    routes: [
      {path, component},
      {path, component},
      {path, component},
      ...
    ]
  });

3.添加到vm对象
  new Vue({
    el, data, ...,
    router: router
  })

--------------------------------------------------------------------------------

router-view       容器
router-link       a标签

--------------------------------------------------------------------------------

命名路由

$route：当前路由的信息

--------------------------------------------------------------------------------

<router-link to="/xxx/xxx">
<router-link :to="{name, params}">

命名路由
new VueRouter({
  routes: [
    {path, component},
    {path, name, component},
  ]
})

--------------------------------------------------------------------------------

获取路由信息：$route
JS控制路由跳转：$router

this.$router.push(
  string|object
);

--------------------------------------------------------------------------------

history是一个栈

--------------------------------------------------------------------------------

push(string|object)      入栈
replace(string|object)   替换最后一个历史纪录(当前)
go(int)
  go(-1)
  go(1)

--------------------------------------------------------------------------------

$route    当前路由信息
$router   操作路由

--------------------------------------------------------------------------------

监视路由：
1.watch——不推荐
  简单——只能看不能干预
2."路由守卫"  ?
  也能控制

--------------------------------------------------------------------------------

多视图
